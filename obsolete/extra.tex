\section{Core Snowball Network Overlay Protocol}
In the discussion of the Snowball protocol we initially assumed a logically fully-connected network of nodes. 
Later, we relaxed that assumption and showed how the network view set intersection between correct nodes can have disjoint subsets and still maintain safety and liveness. 

In this section, we introduce the concrete details of the Snowball network overlay protocol, \textit{SNO}, whose function is to allow the network nodes to maintain a highly-up-to-date view of all active nodes in the system, i.e. allow for churn.
Beyond that, SNO also provides other useful features, including partial detection and prevention of Byzantine behavior, as well as network participation incentivization, which becomes important in the instantiation of the Snowball-based payment system \textit{SnoCoin}. 

\subsection{Background}
SNO makes usage of the core ideas of the Fireflies\cite{johansen2006fireflies} network overlay protocol, but modifies certain operational details. 
The Fireflies protocol forms a ring-based pseudorandom mesh from a network of $\mathcal{N}$ nodes, such that each node has a total of $\mathcal{O}(\log{|\mathcal{N}|})$ neighbors, and such that even if up to half of the neighbors are Byzantine, each correct node will maintain a highly up-to-date view of the entire set of active nodes. 

As before, we still assume for simplicity a logically fully connected network of nodes $\mathcal{N}$.
Each correct node, however, will only need to maintain $\mathcal{O}(\log{|\mathcal{N}|})$ network links.
Let each node $u \in \mathcal{N}$ have some unique identifier, represented by $u$.id, and let \texttt{H} be a secure cryptographic hash function that is pre-image and collision resistant. 
We generate a set of $\log |\mathcal{N}|$ ``rings'', where each ring -- indexed by $i$ such that $1 \leq i \leq 2*|\mathcal{B}| + 1$ -- is an ordering of the nodes based on the output of \texttt{H}($u$.id $||$ $i$), i.e. 
\[
    u.\text{\texttt{pos}}[i] = \text{\texttt{H}}(u.\text{\texttt{id}} || i); \forall u \in \mathcal{N}, 1 \leq i \leq 2|\mathcal{B}| + 1
\]
Nodes have two neighbors (two closest ordered nodes) on each ring, and all nodes can publicly verify the neighbors of other nodes. The first and last nodes wrap around and are always neighbors with each other on every ring. 

The Fireflies overlay guarantees, with high probability, that there exists a path between any two nodes and that this path is pseudorandom. 
Nodes periodically ping other nodes using the pseudorandom mesh generated by the rings structure, and based on the responses can accuse other nodes of failure. 
If a node is accused falsely, then the node may provide evidence of liveness. 
Using this mechanism, each node will maintain a reasonably up-to-date view of all the active nodes in the network and consequently weed out any failed nodes.  
We point the reader to the Fireflies paper for formal proofs.

\subsection{Snowball Network Overlay}
We use the network overlay construction in the Fireflies protocol, but modify it to act as the carrier of messages in the network, rather than just ping nodes periodically.
Every node $u$ chooses the set of $k$ random solicited nodes exactly as before (i.e. from the set of all nodes $\mathcal{N}$). 
This means that the semantics and interface of the Snowball core protocol remain exactly unmodified. 
However, rather than communicate with the solicited nodes directly, the solicitor queries along one of the random paths induced by the random communication mesh. 

For example, suppose that node $u$ chooses a random sample $\mathcal{R} \subset \mathcal{N}_u$ of size $k$ of nodes to solicit, and suppose that the shortest path to node $v \in \mathcal{R}$ is through node $g \in \mathcal{N}_u$. 
$u$ then transmits the message first to $g$, which will queue and forward it to $v$. 

On top of merely forwarding messages, $u$ and $g$ will keep track of the response by $v$. Untimely responses by $v$ will raise accusations by both $u$ and $g$. Enough accusations will result in all correct nodes removing $v$ from their respective network view. 

{\color{blue} Kevin: Expand the subsection here with a more formal protocol description. It should basically be the same as the Fireflies protocol. }

\section{Instantiation}
We now instantiate a payment system with Snowball, called SnoCoin. Before discussing the technical details, we discuss challenges and introduce the solutions adopted in this paper. 

\subsection{Sybils}
\label{subsection:sybil}
Any open and unprotected network can trivially become a victim to a Sybil attack~\cite{douceur2002sybil}, wherein an adversary can cheaply generate a large number of identities and take down the network. 
In Bitcoin, Sybils are deterred through the protocol-level usage of cryptographic puzzles, whose mathematical properties ensure that participation in decision making in the network is costly. 
Since Snowball does not make usage of proofs-of-work, alternative measures must be adopted. 
There are several techniques that may be used. 
Fundamentally, these techniques rely on trading one resource for authorization to participate in the system, but there are big practical differences between the actual resource chosen.
\begin{itemize}
\item IPv4 Scarcity: Many existing peer-to-peer systems, including Bittorrent and Bitcoin, employ Sybil deterrence at their network layer based on the scarcity of IPv4 addresses. 
Specifically, they observe that the IPv4 address space is densely allocated, and that it is difficult for an adversary to amass large numbers of addresses across the Internet.
Bitcoin's main mechanism against eclipse attacks coupled with low-difficulty chain construction is to ensure that a node peers with a diverse set of peers from multiple IP prefixes. 
One possibility, inspired by this mechanism, is to limit the number of participants per prefix. 
Coupled with an IANA-provided map of IP prefix allocations, this may help limit the number of Sybil nodes that an attacker, who has access to a limited number of machines and networks, can bring into the system.
\item Proof-of-Bond: A bond, denominated in the Snowball currency itself to eliminate any dependency on external resources, may be used to raise the costs to launch an attack. 
In this scheme, entry into the system requires the nodes to put up a bond for the duration of their stay in the system. 
This ensures that an attacker has to tie up significant amounts of cash to mount an attack.
Note that this is quite different from traditional proof-of-stake protocols in that it does not suffer from nothing-at-stake, the participants cannot retroactively rewrite history using stale keys, and the bond is not at risk of being usurped by the system.
\item Proof-of-Uniqueness: It is possible to require participants in Snowball to provide a proof-of-uniqueness provided by a secure hardware mechanism. 
One possibility is for every node to run a small, predetermined program in an SGX-like enclave and obtain a certificate that they executed the code on a genuine secure processor. 
This program can then issue just a single random number, derived from the on-chip secret.
\item External Credentials: In domains where the participants are issued a unique credential by an external entity, this credential can be used to authorize the node's entry into the system.
For instance, in settings where participants are issued unique certificates, they may join the network with a join transaction that takes the credential as an input. 
The network can then ensure that any given credential is used by at most one node.

\end{itemize}

SnoCoin adopts a combination of the first two measures to deter participants. We envision SNO to provide a platform for global remittance with the least amount of friction to participation. We envision potentially hundreds of thousands to millions of Internet-connected low-powered devices (such as mobile devices), transacting at peak capacity. Plainly speaking, a combination of the two provides the least amount of resistance for individual honest clients, but provides a reasonable deterrence to an adversary willing to spawn off millions of clusters around the world. 

% \subsection{View and Identity Management}
% {\color{blue}{Kevin: This section is of crucial importance, and needs to be precisely described.}}

% As discussed previously, an inconsistent view amongst correct nodes increases the ability of Byzantine nodes to affect both liveness and safety of the system. 
% Several mechanisms can be used to ensure a highly consistent view, but in SNO we make usage of a two-phase mechanism. 
% In the first phase, we use the proof-of-bond for providing membership into the network. 
% All nodes can authenticate the membership of all other nodes by simply verifying that the bond has been posted. 
% In the second phase, we make usage of Fireflies\cite{johansen2006fireflies}, an intrusion-tolerant network overlay protocol, which provides correct nodes a reasonably fresh view of the set of active nodes in the network, whilst tolerating a Byzantine presence with up to half of all active nodes.
% Constructing such a network overlay provides several benefits. 
% First, it allows correct nodes to efficiently prune out inactive nodes, increasing efficiency of polling in the Snowball protocol. 
% Second, it provides a clean means of rewarding good behavior. 
% Correct nodes that participate and stay active in the network may request rewards in the system in the form of coin minting in SNO. 

\subsection{Failure Detection}

\subsection{Network Congestion Control}
In our analysis, we assumed a Byzantine adversary with powers that, in reality, are extremely difficult to achieve. A large body of work on network congestion control is highly applicable to any instantiation of Snowball. Several relevant techniques are:
\paragraph{Randomized backoff} Whenever a correct node is queried, the node can randomly choose a wait time before responding to the querying node. Although this simple technique makes no distinction between nodes, it is still extremely efficient in reducing the ability of Byzantine nodes to mount attacks. 
\paragraph{Targetted backoff} Additionally, a correct node may keep track of the frequency of requests for each neighbor, and respond to requests accordingly. 

% \subsection{Network View}
% \label{subsection:networkview}
% As in any active open network, it is hard to guarantee that the network view is consistent amongst all correct nodes. 
% In Snowball, we make usage of intrusion tolerant network overlays in order to 

\section{Extra Text}

The advantage of linking the transactions together rather than running
repetitive voting process for each isolated one is two-fold. On the one hand,
the proper policy will create a positive feedback that once a transaction is
supported by most nodes out of its conflict sets, it will become increasingly
likely to be supported in the future.

On the other hand, it makes the system scalable regarding the total number of
transactions, because for each node in the network, every transaction only need
to be voted once.  When the node asks for votes for a newly discovered
transaction, the voting result transitively contributes to all the ancestor
transactions on the DAG\@.  Without the DAG, conflict sets are free-floating with
their transactions, so one has to keep polling for the votes for transactions
in all conflict sets, even the confidence values of oldest ones are rocksolid to
reach a consensus. The reason we have to repeat voting in absence of a DAG is
for a practical system, especially an electronic cash system, any node
should be able to recover from incorrect temporary state seamlessly
to achieve an eventual consistency. This means the consensus protocol is
theoretically always running, but the probabilistic safety guarantee gets
improved over time, so the decision threshold is just an observation from the
current process of consensus and guides the business decisions (e.g.\ whether
to render the service or deliver the goods).  Bitcoin uses the longest chain
rule to represent the current state (decisions) of the transactions, and when a
block is appended to the chain, it enhances the belief on all the preceding
blocks.

Gossip-based protocols are usually designed to work in settings where the nodes
are benign. However, in our system, where Byzantine behavior could present,
some extra care is taken to improve the security given the attackers could push
around incorrect information and disrupt decision making.

The core protocol is mainly pull-based. That is, the only ``pushed''
information is the transaction data, which do not affect the decision process.
Transaction data are neutral, and transactions themselves do not play a role in
making decisions until they are polled. A node only runs the protocol based on
the local information gathered from voting summary sampled at random and will
never need to trust others. The only external information other than
transaction data is the polling result from the sampled nodes. But because the
sampling is controlled by the poller, the attackers could not affect the voting
result if they are not asked, nor could they force the set of nodes to be
polled. There is no exchange of voting result or confidence value between the
nodes. The belief of the chosen transactions are autonomously built by active
sampling and polling, on behalf of the node itself.

2.


The extensive past work on Byzantine consensus can be divided into two families: permissioned and permissionless consensus protocols. 

\paragraph{Permissioned BFT Consensus}
The seminal protocol PBFT~\cite{castro1999practical} protocol was the first Byzantine consensus protocol to guarantee low transaction latency and safety for a network of $3|\mathcal{B}|+1$ nodes.  
PBFT entails quadratic $\mathcal{O}(|\mathcal{N}|^2)$ message complexity and its guarantees break down non-gracefully with bound violation. 
Abd-El-Malek et al.~\cite{abd2005fault} and Cowling et al.~\cite{cowling2006hq} use a quorum-based approach to optimize for contention-free cases of operation to achieve consensus in only a single round of communication. 
However, although these protocols improve on performance, they degrade very poorly under contention. 
Zyzzyva~\cite{kotla2007zyzzyva} couples BFT with speculative execution to improve the failure-free operation case. 
Guerraoui et al.~\cite{guerraoui2010next} introduce a protocol with optimized performance under several -- rather than just one -- cases of execution. 
In contrast, Clement et al.~\cite{clement2009making} sacrificed some performance to tolerate worst-case degradation, providing a more uniform execution profile. 
This work, in particular, sacrificed failure-free optimizations to provide consistent throughput even at high number of failures. 

Other past work in permissioned BFT systems typically requires at least $2|\mathcal{B}|+1$ replicas tolerance. 
However, work in 2012 by Kapitza et al.~\cite{kapitza2012cheapbft} showed how to leverage trusted hardware components to construct a protocol that uses $|\mathcal{B}|+1$ replicas. 

On the other end of the spectrum, other work attempts to introduce new protocols under redefinitions and relaxations of the BFT model. 
Rodrigues et al.~\cite{rodrigues2007large} modify PBFT to allow for arbitrary choice of number of replicas and failure threshold, providing a probabilistic guarantee of liveness for some failure ratio but protecting safety with high probability. 
Such relaxation of the BFT protocol is a core design principle of Snowball, where we postulate that for a payment system such as SnoCoin, safety is far more important than liveness. 
In another form of relaxation, the work of Singh et al.~\cite{singh2009zeno} introduced a BFT state machine replication protocol that trades consistency for high availability. 
More specifically, this paper guarantees eventual consistency rather than linearizability, meaning that participants can be inconsistent but eventually agree once the network stabilizes. 
By providing an even weaker consistency guarantee, namely fork-join-causal consistency, in 2011 Mahajan et al.\cite{mahajan2011depot} described a protocol that guarantees safety under $|\mathcal{B}|+1$ replicas. 

\paragraph{Permissionless BFT Consensus}
Bitcoin~\cite{nakamoto2008bitcoin} was the first protocol to show the possibility of consensus under no predefined set of identities. The core insight is the usage of proof-of-work (PoW) to replace voting by identities with voting by computational power. While techniques based on proof-of-work~\cite{dwork1992pricing,aspnes2005exposing}, and even cryptocurrencies with minting based on proof-of-work~\cite{vishnumurthy2003karma,rivest1997payword}, had been explored before, Bitcoin was the first to incorporate PoW into its consensus process.

Bitcoin, however, has at least two major weaknesses: performance and scale. 
Bitcoin incurs high confirmation latency at around 10 minutes, is hard-capped at 7 transactions/sec maximum throughput, and exhibits significant short-term variance in both of these metrics due to its mining protocol -- it is not uncommon for transactions to take much more than an hour to confirm. 
These fundamental protocol limits pose problems for the protocol's scale~\cite{croman2016scaling}. 
Further, nodes can take up to a few days to start up, as validating the blockchain involves vetting every single transaction since the deployment of the system. 
The MimbleWimble~\cite{mimblewimble} proposal promises to save on disk storage by pruning spent transactions through homomorphic cryptography. 

In the last two years, a flurry of protocols that tackle scale and efficiency of Bitcoin have been proposed. 
Bitcoin-NG~\cite{eyal2016bitcoin} refactors the creation of blocks such that block dissemination is no longer a bottleneck.
In a similar fashion, both Pass et al.~\cite{pass2016hybrid} and ByzCoin~\cite{kokoris2016enhancing} make use of the underlying PoW mechanism to choose quorums to process transactions in each epoch, using PBFT.
Luu et al.~\cite{luusharding2016} similarly use PoW to create logarithmic-sized shards upon which protocols like PBFT can be run.
All of these systems still rely crucially on proof of work, and thus do not tackle a crucial inefficiency.

Proof of stake (PoS) protocols, which employ variants of PBFT among a cohort of nodes whose desired behavior is incentivized through a financial bond, have been suggested as a way to replace computationally wasteful proofs of work. 
While there have been many PoS proposals~\cite{peercoin,NXT,steem,casper,bentovpoa}, few of them have any associated proof of correctness.
Algorand~\cite{micali2017algorand}, Snow White~\cite{bentovsnow} and Ouroboros~\cite{kiayias2016provably} are some of the earliest provably secure proof-of-stake (PoS) protocols. Of these, Snow White provides the strongest guarantees, as it provides both liveness and safety for a system of at most half adversarial nodes. 

{\color{blue}Kevin: further discussions need to go here about related works. There is some stuff in the related works section that maybe doesn't even really belong all that much, and definitely some stuff that's kind of missing, especially in the latest wave of work.}


------------------------------------------------------------------------------------------------

\section{Future Work}
\begin{itemize}
    \item \textbf{Network Model}: we conjecture this protocol family also works
        under a partially synchronous network assumption. This is because the
        sampling and querying process makes the system self-synchronized,
        and our current randomized global scheduler model is weaker
        than the round-based model used by strongly synchronized protocols.
        A new model or model transformation is expected.
    \item \textbf{Minting}: in order to build a decentralized cryptocurrency,
        we need a minting mechanism that incentivizes correct behavior of nodes.
    \item \textbf{Membership}: to build a permissionless system, a complete
        staking and unstaking mechanism needs to be implemented, which may fusion into
        the existing Avalanche protocol to benefit from its safety guarantees.
    \item \textbf{Joining}: since Avalanche has relatively high throughput,
        it may take very long time for a new node to catch up the entire history of DAG using
        the existing mechanism.
\end{itemize}

